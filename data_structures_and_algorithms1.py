# -*- coding: utf-8 -*-
"""data_structures_and_algorithms1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YQ2FGgKWGZ34eE2t511w5v99AT1bC41w
"""

def count_rotation_linear(nums):
    position = 0

    while position < len(nums):
        if position > 0 and nums[position] < nums[position - 1]:
            return position
        position += 1

    return 0

# Test Cases
tests = [
    ([3, 4, 5, 1, 2], 3),       # Rotated 3 times
    ([1, 2, 3, 4, 5], 0),       # Not rotated
    ([2, 3, 4, 5, 1], 4),       # Rotated 4 times
    ([5, 1, 2, 3, 4], 1),       # Rotated once
    ([7, 9, 11, 12, 5], 4),     # Rotated 4 times
    ([1], 0),                   # Single element
    ([2, 1], 1),                # Rotated once (two elements)
    ([4, 5, 6, 7, 0, 1, 2], 4)  # Rotated 4 times
]

9# Run Tests
for i, (nums, expected) in enumerate(tests):
    result = count_rotation_linear(nums)
    print(f"Test {i+1}: Got {result}, Expected {expected}")
    assert result == expected, f"Test {i+1} Failed!"

print("\nAll tests passed!")

def count_rotation_binary(nums):
    lo = 0
    hi = len(nums) - 1

    while lo <= hi:
        mid = (lo + hi) // 2
        mid_number = nums[mid]

        # Check if mid is the rotation point
        if mid > 0 and mid_number < nums[mid - 1]:
            return mid
        elif mid_number < nums[hi]:
            hi = mid - 1
        else:
            lo = mid + 1

    return 0

# Test Cases
tests = [
    ([3, 4, 5, 1, 2], 3),
    ([1, 2, 3, 4, 5], 0),
    ([2, 3, 4, 5, 1], 4),
    ([5, 1, 2, 3, 4], 1),
    ([7, 9, 11, 12, 5], 4),
    ([1], 0),
    ([2, 1], 1),
    ([4, 5, 6, 7, 0, 1, 2], 4)
]

# Run Tests
for i, (nums, expected) in enumerate(tests):
    result = count_rotation_binary(nums)
    print(f"Test {i+1}: Got {result}, Expected {expected}")
    assert result == expected, f"Test {i+1} Failed!"

print("\nAll tests passed!")

class user:
  def __init__(self, username, name, email):
    self.username = username
    self.name = name
    self.email = email

  def introduce_yourself(self, guest_name):
    print(f"Hi {guest_name}, my name is {self.name}!")

user1=user('jane', 'jane doe', 'jane@doe')
user1.introduce_yourself('john')

class user:
  def __init__(self, username, name, email):
    self.username = username
    self.name = name
    self.email = email

    def __repr__(self):
      return "User(username='{}', name='{}', email='{}')".format(self.username, self.name, self.email)

    def __str__(self):
      return self.__repr__()

user2=user('jane', 'jane doe', 'jane@doe')
  user2

class user:
  def __init__(self):
    self.users = []

  def insert(self, user):
    i=0
    while i < len(self.users):
      if self.users[i].username > user.username:
        break
      i += 1
    self.users.insert(i, user)

  def find(self, username):
    for user in self.users:
      if user.username == username:
        return user

  def update(self, user):
    target = self.find(user.username)
    target.name, target.email = user.name, user.email

  def list_all(self):
    return self.users

# User data class
class User:
    def __init__(self, username, name, email):
        self.username = username
        self.name = name
        self.email = email

    def __repr__(self):
        return f"User(username='{self.username}', name='{self.name}', email='{self.email}')"

# User manager class
class UserManager:
    def __init__(self):
        self.users = []

    def insert(self, user):
        i = 0
        while i < len(self.users):
            if self.users[i].username > user.username:
                break
            i += 1
        self.users.insert(i, user)

    def find(self, username):
        for user in self.users:
            if user.username == username:
                return user
        return None

    def update(self, user):
        target = self.find(user.username)
        if target:
            target.name = user.name
            target.email = user.email

    def list_all(self):
        return self.users

# Create user manager
manager = UserManager()

# Insert users
manager.insert(User("alice", "Alice Smith", "alice@example.com"))
manager.insert(User("bob", "Bob Johnson", "bob@example.com"))
manager.insert(User("charlie", "Charlie Rose", "charlie@example.com"))

# List all users (should be sorted by username)
print("All users:", manager.list_all())

# Find a user
user = manager.find("bob")
print("Found user:", user)

# Update user
manager.update(User("bob", "Bob Marley", "bob@newmail.com"))

# Check update
print("Updated users:", manager.list_all())

# Try to find a non-existing user
print("Find non-existing user:", manager.find("david"))

#binary tree
class treenode:
  def __init__(self, key):
    self.key = key
    self.left = None
    self.right = None

node0= treenode(3)
node1= treenode(4)
node2= treenode(5)
node0.key
node0.left=node1
node0.right=node2
tree = node0
print(tree.key)
print(tree.left.key)
print(tree.right.key)

tree_tuple = ((1,3,None), 2, ((None, 3, 4), 5, (6, 7, 8)))

def parse_tuple(data):
  if isinstance(data, tuple) and len(data) == 3:
    node = treenode(data[1])
    node.left = parse_tuple(data[0])
    node.right = parse_tuple(data[2])
  elif data is None:
    node = None
  else:
    node = treenode(data)
  return node

# Define the tuple
tree_data = ((1, 2, (3, 4, 5)))

# Parse it into a tree
tree = parse_tuple(tree_data)

# Inorder Traversal to verify structure
def inorder(node):
    if node is None:
        return []
    return inorder(node.left) + [node.key] + inorder(node.right)

print("Inorder Traversal:", inorder(tree))

def postorder(node):
    if node is None:
        return []
    return postorder(node.left) + postorder(node.right) + [node.key]

def tree_height(node):
  if node is None:
    return 0
  return 1 + max(tree_height(node.left), tree_height(node.right))

tree_height(tree)

def tree_size(node):
  if node is None:
    return 0
  return 1 + tree_size(node.left) + tree_size(node.right)

tree_size(tree)

class treenode():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

    def height(self):
        if self.left is None and self.right is None:
            return 1
        left_height = self.left.height() if self.left else 0
        right_height = self.right.height() if self.right else 0
        return 1 + max(left_height, right_height)

    def size(self):
        left_size = self.left.size() if self.left else 0
        right_size = self.right.size() if self.right else 0
        return 1 + left_size + right_size

    def transversal_inorder(self):
        result = []
        if self.left:
            result += self.left.transversal_inorder()
        result.append(self.key)
        if self.right:
            result += self.right.transversal_inorder()
        return result

    def display_keys(self, space='\t', level=0):
        if self.right:
            self.right.display_keys(space, level+1)
        print(space*level + str(self.key))
        if self.left:
            self.left.display_keys(space, level+1)

    def transversal_preorder(self):
        result = [self.key]
        if self.left:
            result += self.left.transversal_preorder()
        if self.right:
            result += self.right.transversal_preorder()
        return result

    def to_tuple(self):
        if self.left is None and self.right is None:
            return self.key
        left = self.left.to_tuple() if self.left else None
        right = self.right.to_tuple() if self.right else None
        return (left, self.key, right)

    def __str__(self):
        return "BinaryTree <{}>".format(self.to_tuple())

    def __repr__(self):
        return "BinaryTree <{}>".format(self.to_tuple())

    @staticmethod
    def parse_tuple(data):
        if data is None:
            return None
        if isinstance(data, tuple) and len(data) == 3:
            node = treenode(data[1])
            node.left = treenode.parse_tuple(data[0])
            node.right = treenode.parse_tuple(data[2])
            return node
        return treenode(data)

# Sample tree: ((1, 2, None), 3, (4, 5, 6))
tree_data = ((1, 2, None), 3, (4, 5, 6))

# Parse to tree
tree = treenode.parse_tuple(tree_data)

# Display tree
print("Tree Structure:")
tree.display_keys()

# Print traversals
print("Inorder:", tree.transversal_inorder())
print("Preorder:", tree.transversal_preorder())
print("Size:", tree.size())
print("Height:", tree.height())
print("Tree as tuple:", tree.to_tuple())

def remove_none(nums):
    return [x for x in nums if x is not None]

def is_bst(node):
    if node is None:
        return True, None, None

    is_bst_l, min_l, max_l = is_bst(node.left)
    is_bst_r, min_r, max_r = is_bst(node.right)

    is_bst_node = (is_bst_l and is_bst_r and
                   (max_l is None or node.key > max_l) and
                   (min_r is None or node.key < min_r))

    min_key = min(remove_none([min_l, node.key, min_r]))
    max_key = max(remove_none([max_l, node.key, max_r]))

    if is_bst_node:
        return True, min_key, max_key
    else:
        return False, None, None

# Using previous treenode class
tree1 = treenode.parse_tuple(((1, 2, None), 3, (4, 5, 6)))  # This is NOT a BST

tree2 = treenode.parse_tuple(((1, 2, None), 3, (None, 4, 5)))  # This IS a BST

print("Tree 1 is BST:", is_bst(tree1)[0])  # Output: False
print("Tree 2 is BST:", is_bst(tree2)[0])  # Output: True

class BSTNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.left = None
        self.right = None
        self.parent = None

    def __repr__(self):
        return f"({self.key}: {self.value})"
def insert(node, key, value):
  if node is None:
    node = BSTNode(key, value)
  elif key < node.key:
    node.left = insert(node.left, key, value)
    node.left.parent = node
  elif key>node.key:
    node.right= insert(node.right, key, value)
    node.right.parent = node
  return node

# Create a tree and insert values with different names as keys
root = None
root = insert(root, "bob", "Bob Smith")
root = insert(root, "alice", "Alice Johnson")
root = insert(root, "charlie", "Charlie Brown")
root = insert(root, "david", "David Wright")

def inorder(node):
    if node is None:
        return []
    return inorder(node.left) + [(node.key, node.value)] + inorder(node.right)

print("Inorder Traversal of BST:")
print(inorder(root))

def find(node, key):
  if node is None:
    return None
  if key == node.key:
    return node
  if key < node.key:
    return find(node.left, key)
  if key > node.key:
    return find(node.right, key)

root = find(root, "alice")
print(root)

def update(node, key, value):
  target = find(node, key)
  if target is not None:
    target.value = value

def list_all(node):
  if node is None:
    return []
  return list_all(node.left) + [(node.key, node.value)] + list_all(node.right)

list_all(root)

def is_balanced(node):
  if node is None:
    return True, 0

  balanced_l, height_l = is_balanced(node.left)
  balanced_r, height_r = is_balanced(node.right)
  balanced = balanced_l and balanced_r and abs(height_l - height_r) <= 1
  height = 1 + max(height_l, height_r)
  return balanced, height

class BSTNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.left = None
        self.right = None
        self.parent = None

    def __repr__(self):
        return f"({self.key}: {self.value})"
#balanced binary search tree
def make_balanced_bat(data, lo=0, hi=None, parent=None):
  if hi is None:
    hi = len(data) - 1
  if lo > hi:
    return None
  mid = (lo + hi) // 2
  key, value = data[mid]
  root = BSTNode(key, value)
  root.parent = parent
  root.left = make_balanced_bat(data, lo, mid-1, root)
  root.right = make_balanced_bat(data, mid+1, hi, root)
  return root

# Sorted list of key-value pairs
data = [
    (1, "one"),
    (2, "two"),
    (3, "three"),
    (4, "four"),
    (5, "five"),
    (6, "six"),
    (7, "seven")
]

# Create balanced BST
root = make_balanced_bat(data)

# Inorder traversal to check
def inorder(node):
    if node is None:
        return []
    return inorder(node.left) + [(node.key, node.value)] + inorder(node.right)

print("Inorder Traversal (should be sorted):")
print(inorder(root))

# Commented out IPython magic to ensure Python compatibility.
# %%time
# for i in range(26):
#   j = i*i

# Commented out IPython magic to ensure Python compatibility.
# %%time
# for i in range(100000000):
#   j = i*i

class BSTNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.left = None
        self.right = None
        self.parent = None

    def __repr__(self):
        return f"({self.key}: {self.value})"

def find(node, key):
    while node:
        if key == node.key:
            return node
        elif key < node.key:
            node = node.left
        else:
            node = node.right
    return None

def insert(node, key, value):
    if node is None:
        return BSTNode(key, value)
    elif key < node.key:
        node.left = insert(node.left, key, value)
        node.left.parent = node
    elif key > node.key:
        node.right = insert(node.right, key, value)
        node.right.parent = node
    return node

def update(node, key, value):
    target = find(node, key)
    if target:
        target.value = value

def list_all(node):
    if node is None:
        return []
    return list_all(node.left) + [(node.key, node.value)] + list_all(node.right)

def tree_size(node):
    if node is None:
        return 0
    return 1 + tree_size(node.left) + tree_size(node.right)

def display_keys(node, space='\t', level=0):
    if node is None:
        print(space * level + '∅')
        return
    display_keys(node.right, space, level + 1)
    print(space * level + str((node.key, node.value)))
    display_keys(node.left, space, level + 1)

def balance_bst(node):
    items = list_all(node)
    return make_balanced_bst(items)

def make_balanced_bst(data, lo=0, hi=None, parent=None):
    if hi is None:
        hi = len(data) - 1
    if lo > hi:
        return None

    mid = (lo + hi) // 2
    key, value = data[mid]
    root = BSTNode(key, value)
    root.parent = parent

    root.left = make_balanced_bst(data, lo, mid-1, root)
    root.right = make_balanced_bst(data, mid+1, hi, root)

    return root

class treemap():
    def __init__(self):
        self.root = None

    def __setitem__(self, key, value):
        node = find(self.root, key)
        if not node:
            self.root = insert(self.root, key, value)
            self.root = balance_bst(self.root)
        else:
            update(self.root, key, value)

    def __getitem__(self, key):
        node = find(self.root, key)
        return node.value if node else None

    def __iter__(self):
        return (x for x in list_all(self.root))

    def __len__(self):
        return tree_size(self.root)

    def display(self):
        return display_keys(self.root)

# Create treemap and insert values
tm = treemap()
tm["d"] = "dog"
tm["b"] = "bat"
tm["a"] = "apple"
tm["c"] = "cat"
tm["e"] = "elephant"

# Display tree
print("Tree structure:")
tm.display()

# Test get
print("\nGet 'c':", tm["c"])  # Should print 'cat'
print("Get 'x':", tm["x"])    # Should print None

# Test iteration
print("\nAll key-value pairs (in order):")
for item in tm:
    print(item)

# Test length
print("\nTree size:", len(tm))

